<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>acidmartin.com</title>
  <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
    :root {
      --c1: #ff00ff; --c2: #00ffff; --c3: #ff6600; --c4: #00ff66; --c5: #6600ff;
    }
    html, body { width: 100%; height: 100%; overflow: hidden; background: #000; font-family: 'Space Mono', monospace; }
    #blobCanvas    { position: fixed; inset: 0; z-index: 1; opacity: 0.35; mix-blend-mode: screen; }
    #plasmaCanvas  { position: fixed; inset: 0; z-index: 2; opacity: 0.18; mix-blend-mode: screen; }
    #tunnelCanvas  { position: fixed; inset: 0; z-index: 3; }
    #particleCanvas{ position: fixed; inset: 0; z-index: 4; }
    #lightningCanvas{ position: fixed; inset: 0; z-index: 8; pointer-events: none; }
    body::after {
      content: ''; position: fixed; inset: 0;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.08'/%3E%3C/svg%3E");
      background-size: 200px 200px; pointer-events: none; z-index: 5; opacity: 0.4; mix-blend-mode: overlay;
    }
    .stage { position: fixed; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 10; pointer-events: none; }
    .glitch { font-size: clamp(3rem, 10vw, 8rem); font-weight: 700; color: #fff; letter-spacing: 0.05em; text-transform: lowercase; position: relative; animation: flicker 8s infinite; transition: transform 0.05s, text-shadow 0.05s; }
    .glitch::before, .glitch::after { content: attr(data-text); position: absolute; inset: 0; }
    .glitch::before { color: var(--c1); clip-path: polygon(0 20%, 100% 20%, 100% 40%, 0 40%); animation: glitch-top 3s infinite steps(2); mix-blend-mode: screen; }
    .glitch::after  { color: var(--c2); clip-path: polygon(0 60%, 100% 60%, 100% 80%, 0 80%); animation: glitch-bot 2.5s infinite steps(2); mix-blend-mode: screen; }
    .sub { margin-top: 1.5rem; font-size: clamp(0.7rem, 2vw, 1rem); letter-spacing: 0.4em; text-transform: uppercase; color: rgba(255,255,255,0.5); animation: pulse-sub 4s ease-in-out infinite; }
    .sub::before { content: 'â–¶ '; color: var(--c3); animation: blink 1s step-end infinite; }
    .scanline { position: fixed; inset: 0; background: repeating-linear-gradient(to bottom, transparent 0px, transparent 3px, rgba(0,0,0,0.08) 3px, rgba(0,0,0,0.08) 4px); pointer-events: none; z-index: 6; }
    .vignette  { position: fixed; inset: 0; background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.85) 100%); pointer-events: none; z-index: 7; }
    .rgb-border { position: relative; padding: 2rem 4rem; border: 1px solid rgba(255,255,255,0.08); animation: border-pulse 4s ease-in-out infinite; }
    .rgb-border::before { content: ''; position: absolute; inset: -2px; background: linear-gradient(90deg, var(--c1), var(--c2), var(--c3), var(--c4), var(--c5), var(--c1)); background-size: 300% 100%; border-radius: 2px; z-index: -1; animation: rainbow-border 3s linear infinite; opacity: 0.6; }
    .rgb-border::after  { content: ''; position: absolute; inset: 0; background: rgba(0,0,0,0.92); z-index: -1; }

    /* Mute button */
    #muteBtn {
      position: fixed; bottom: 24px; right: 24px; z-index: 999;
      width: 40px; height: 40px;
      background: rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 50%;
      cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      color: rgba(255,255,255,0.6);
      font-size: 16px;
      transition: border-color 0.3s, color 0.3s, box-shadow 0.3s;
      backdrop-filter: blur(8px);
      font-family: inherit;
    }
    #muteBtn:hover {
      border-color: rgba(0,255,255,0.5);
      color: #fff;
      box-shadow: 0 0 12px rgba(0,255,255,0.3);
    }

    /* Audio start overlay */
    #startOverlay {
      position: fixed; inset: 0; z-index: 9999;
      display: flex; align-items: center; justify-content: center;
      background: rgba(0,0,0,0.9);
      cursor: pointer;
      flex-direction: column; gap: 1.2rem;
    }
    #startOverlay span {
      font-family: 'Space Mono', monospace;
      font-size: clamp(0.7rem, 1.5vw, 0.9rem);
      letter-spacing: 0.35em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.35);
    }
    #startOverlay .pulse-ring {
      width: 80px; height: 80px;
      border: 2px solid rgba(0,255,255,0.6);
      border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      color: rgba(0,255,255,0.8);
      font-size: 28px;
      animation: ring-pulse 2s ease-in-out infinite;
    }
    @keyframes ring-pulse {
      0%,100%{ box-shadow: 0 0 0 0 rgba(0,255,255,0.3); }
      50%{ box-shadow: 0 0 0 20px rgba(0,255,255,0); }
    }
    @keyframes glitch-top { 0%{transform:translate(-3px,0)} 25%{transform:translate(3px,0)} 50%{transform:translate(-1px,0) skewX(5deg)} 75%{transform:translate(2px,0)} 100%{transform:translate(-3px,0)} }
    @keyframes glitch-bot { 0%{transform:translate(3px,0)} 33%{transform:translate(-3px,0) skewX(-3deg)} 66%{transform:translate(1px,0)} 100%{transform:translate(3px,0)} }
    @keyframes flicker { 0%,95%,100%{opacity:1} 96%{opacity:.4} 97%{opacity:1} 98%{opacity:.2} 99%{opacity:1} }
    @keyframes pulse-sub { 0%,100%{opacity:.5} 50%{opacity:1;color:rgba(255,255,255,.9);letter-spacing:.5em} }
    @keyframes blink { 0%,100%{opacity:1} 50%{opacity:0} }
    @keyframes rainbow-border { 0%{background-position:0% 50%} 100%{background-position:300% 50%} }
    @keyframes border-pulse { 0%,100%{box-shadow:0 0 0 transparent} 50%{box-shadow:0 0 30px rgba(255,0,255,.15),0 0 60px rgba(0,255,255,.1)} }
  </style>
</head>
<body>

<!-- Click to start overlay (browser autoplay policy requires user gesture) -->
<div id="startOverlay">
  <div class="pulse-ring">â–¶</div>
  <span>click to enter</span>
</div>

<!--
  â˜… TO ADD YOUR SONG:
    1. Upload your audio file to the same GitHub repo folder as index.html
    2. Rename it to "song.mp3" (or update the src below to match your filename)
    3. Commit and push â€” GitHub Pages will serve it automatically
-->
<audio id="bgAudio" loop>
  <source src="song.wav" type="audio/wav">
</audio>

<canvas id="blobCanvas"></canvas>
<canvas id="plasmaCanvas"></canvas>
<canvas id="tunnelCanvas"></canvas>
<canvas id="particleCanvas"></canvas>
<canvas id="lightningCanvas"></canvas>
<div class="scanline"></div>
<div class="vignette"></div>
<div class="stage">
  <div class="rgb-border" id="logoBox">
    <div class="glitch" data-text="acidmartin" id="logoText">acidmartin</div>
    <div class="sub">something is coming</div>
  </div>
</div>

<button id="muteBtn" title="Toggle sound">ðŸ”Š</button>

<script>
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  //  AUDIO + WEB AUDIO API SETUP
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const audio = document.getElementById('bgAudio');
  const muteBtn = document.getElementById('muteBtn');
  const startOverlay = document.getElementById('startOverlay');

  let audioCtx, analyser, dataArray, bufferLength;
  let audioReady = false;
  let smoothBass = 0;

  function initAudio() {
    if (audioReady) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const source = audioCtx.createMediaElementSource(audio);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    analyser.smoothingTimeConstant = 0.82;
    bufferLength = analyser.frequencyBinCount;
    dataArray = new Uint8Array(bufferLength);
    source.connect(analyser);
    analyser.connect(audioCtx.destination);
    audioReady = true;
  }

  startOverlay.addEventListener('click', () => {
    initAudio();
    audio.play().catch(()=>{});
    startOverlay.style.opacity = '0';
    startOverlay.style.transition = 'opacity 0.8s';
    setTimeout(() => startOverlay.style.display = 'none', 800);
  });

  muteBtn.addEventListener('click', () => {
    audio.muted = !audio.muted;
    muteBtn.textContent = audio.muted ? 'ðŸ”‡' : 'ðŸ”Š';
  });

  function getBassEnergy() {
    if (!audioReady) return 0;
    analyser.getByteFrequencyData(dataArray);
    // Bass: 20Hzâ€“250Hz (sub-bass + bass region â€” best for visual punch)
    const nyquist = audioCtx.sampleRate / 2;
    const binHz = nyquist / bufferLength;
    const bassEnd = Math.floor(250 / binHz);
    let sum = 0;
    for (let i = 1; i <= bassEnd; i++) sum += dataArray[i];
    return sum / (bassEnd * 255); // normalized 0..1
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  //  CANVAS SETUP
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let W, H, cx, cy;
  const mouse = { x: -9999, y: -9999 };
  const blobCanvas      = document.getElementById('blobCanvas');
  const plasmaCanvas    = document.getElementById('plasmaCanvas');
  const tunnelCanvas    = document.getElementById('tunnelCanvas');
  const particleCanvas  = document.getElementById('particleCanvas');
  const lightningCanvas = document.getElementById('lightningCanvas');
  const bctx  = blobCanvas.getContext('2d');
  const plctx = plasmaCanvas.getContext('2d');
  const tctx  = tunnelCanvas.getContext('2d');
  const pctx  = particleCanvas.getContext('2d');
  const lctx  = lightningCanvas.getContext('2d');

  // offscreen for plasma
  let plasmaOffscreen, plasmaOffCtx;

  function resize() {
    W = window.innerWidth; H = window.innerHeight; cx = W/2; cy = H/2;
    [blobCanvas, plasmaCanvas, tunnelCanvas, particleCanvas, lightningCanvas]
      .forEach(c => { c.width = W; c.height = H; });
    // plasma at 1/4 res for performance
    plasmaOffscreen = document.createElement('canvas');
    plasmaOffscreen.width = Math.floor(W/4);
    plasmaOffscreen.height = Math.floor(H/4);
    plasmaOffCtx = plasmaOffscreen.getContext('2d');
    updateLogoCenter();
  }
  window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
  window.addEventListener('touchmove', e => { mouse.x=e.touches[0].clientX; mouse.y=e.touches[0].clientY; }, {passive:true});
  window.addEventListener('resize', resize);

  function hsl(h,s,l,a=1){ return `hsla(${h},${s}%,${l}%,${a})`; }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  //  BLOBS
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const blobs = Array.from({length:7},(_,i)=>({
    x: Math.random()*window.innerWidth,
    y: Math.random()*window.innerHeight,
    vx:(Math.random()-.5)*.4, vy:(Math.random()-.5)*.4,
    r: 130+Math.random()*170,
    hue:(i/7)*360, phase:Math.random()*Math.PI*2,
    morphSpeed:.003+Math.random()*.004,
  }));

  function drawBlobs(bass) {
    bctx.clearRect(0,0,W,H);
    blobs.forEach(b=>{
      b.x+=b.vx; b.y+=b.vy;
      if(b.x<-b.r)b.x=W+b.r; if(b.x>W+b.r)b.x=-b.r;
      if(b.y<-b.r)b.y=H+b.r; if(b.y>H+b.r)b.y=-b.r;
      b.hue=(b.hue+.08)%360; b.phase+=b.morphSpeed;
      const expand = 1 + bass * 0.5;
      const pts=12;
      bctx.beginPath();
      for(let i=0;i<=pts;i++){
        const angle=(i/pts)*Math.PI*2;
        const morph=b.r*expand*(.72+.28*Math.sin(b.phase+i*1.1+Math.cos(b.phase*.7+i)));
        const x=b.x+Math.cos(angle)*morph, y=b.y+Math.sin(angle)*morph;
        i===0?bctx.moveTo(x,y):bctx.lineTo(x,y);
      }
      bctx.closePath();
      const g=bctx.createRadialGradient(b.x,b.y,0,b.x,b.y,b.r*expand);
      g.addColorStop(0,hsl(b.hue,100,65,.9));
      g.addColorStop(.5,hsl((b.hue+40)%360,100,50,.5));
      g.addColorStop(1,hsl((b.hue+80)%360,100,40,0));
      bctx.fillStyle=g;
      bctx.filter='blur(38px)';
      bctx.fill();
      bctx.filter='none';
    });
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  //  PLASMA LAYER
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let pt = 0;
  function drawPlasma(bass) {
    const iw = plasmaOffscreen.width, ih = plasmaOffscreen.height;
    const imgData = plasmaOffCtx.createImageData(iw, ih);
    const d = imgData.data;
    const t = pt;
    for (let y = 0; y < ih; y++) {
      for (let x = 0; x < iw; x++) {
        const nx = x / iw, ny = y / ih;
        const v1 = Math.sin(nx * 10 + t);
        const v2 = Math.sin(ny * 10 + t * 1.3);
        const v3 = Math.sin((nx + ny) * 8 + t * 0.7);
        const v4 = Math.sin(Math.sqrt((nx-.5)**2+(ny-.5)**2)*20 - t*1.5 + bass*5);
        const v = (v1+v2+v3+v4)/4;
        const hue = (((v+1)/2)*360 + t*30) % 360;
        const h6 = hue/60, s=1, l=0.45;
        const c=(1-Math.abs(2*l-1))*s;
        const xc=c*(1-Math.abs(h6%2-1));
        let r=0,g=0,b=0;
        if(h6<1){r=c;g=xc;}else if(h6<2){r=xc;g=c;}
        else if(h6<3){g=c;b=xc;}else if(h6<4){g=xc;b=c;}
        else if(h6<5){r=xc;b=c;}else{r=c;b=xc;}
        const m=l-c/2;
        const idx=(y*iw+x)*4;
        d[idx]=Math.round((r+m)*255);
        d[idx+1]=Math.round((g+m)*255);
        d[idx+2]=Math.round((b+m)*255);
        d[idx+3]=200;
      }
    }
    plasmaOffCtx.putImageData(imgData,0,0);
    plctx.clearRect(0,0,W,H);
    plctx.filter='blur(3px)';
    plctx.drawImage(plasmaOffscreen,0,0,W,H);
    plctx.filter='none';
    pt += 0.014 + bass * 0.05;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  //  TUNNEL
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let tt=0;
  const RINGS=44, SPOKES=14;
  function drawTunnel(bass){
    tctx.clearRect(0,0,W,H);
    const maxR=Math.sqrt(cx*cx+cy*cy)*1.2;
    for(let i=RINGS;i>=0;i--){
      const p=i/RINGS, r=maxR*p, depth=1-p;
      const hue=(tt*30+i*15)%360, sat=80+Math.sin(tt*.5+i*.3)*20, lit=10+depth*20;
      tctx.beginPath(); tctx.arc(cx,cy,r,0,Math.PI*2);
      tctx.strokeStyle=hsl(hue,sat,lit,.15+depth*.2+bass*.2); tctx.lineWidth=1.5+bass*3; tctx.stroke();
    }
    for(let s=0;s<SPOKES;s++){
      const angle=(s/SPOKES)*Math.PI*2+tt*.2+bass*.5, hue=(tt*20+s*30)%360;
      tctx.beginPath(); tctx.moveTo(cx,cy);
      tctx.lineTo(cx+Math.cos(angle)*maxR, cy+Math.sin(angle)*maxR);
      const g=tctx.createLinearGradient(cx,cy,cx+Math.cos(angle)*maxR,cy+Math.sin(angle)*maxR);
      g.addColorStop(0,hsl(hue,100,60,.5+bass*.4)); g.addColorStop(1,hsl((hue+180)%360,100,60,0));
      tctx.strokeStyle=g; tctx.lineWidth=1+bass*2; tctx.stroke();
    }
    tt+=.012;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  //  PARTICLES + ENHANCED CURSOR
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const N=160, CDIST=140, MDIST=220;
  const particles=Array.from({length:N},(_,i)=>({
    x:Math.random()*window.innerWidth, y:Math.random()*window.innerHeight,
    vx:(Math.random()-.5)*.5, vy:(Math.random()-.5)*.5,
    r:1.5+Math.random()*2, hue:Math.random()*360,
    orbit: i < 30, // ~30 orbit the cursor
    orbitR: 25 + Math.random()*90, orbitSpeed: (Math.random()-.5)*.05,
    orbitAngle: Math.random()*Math.PI*2,
  }));

  const cursorRings = [
    {r:18, phase:0, speed:0.05},
    {r:36, phase:2.1, speed:-0.035},
    {r:58, phase:4.2, speed:0.025},
  ];
  let cursorTime = 0;

  function drawParticles(bass){
    pctx.clearRect(0,0,W,H);

    // Electric cursor rings
    if(mouse.x > 0) {
      cursorRings.forEach(ring=>{
        ring.phase += ring.speed + bass*0.08;
        const pts = 20;
        pctx.beginPath();
        for(let i=0;i<=pts;i++){
          const a = (i/pts)*Math.PI*2 + ring.phase;
          const jitter = ring.r + (Math.random()-.5)*8*(1+bass*3);
          const x = mouse.x + Math.cos(a)*jitter;
          const y = mouse.y + Math.sin(a)*jitter;
          i===0?pctx.moveTo(x,y):pctx.lineTo(x,y);
        }
        pctx.closePath();
        pctx.strokeStyle=hsl((cursorTime*80+ring.r*4)%360,100,72,.35+bass*.5);
        pctx.lineWidth=1.2; pctx.stroke();
      });
    }
    cursorTime += 0.016;

    particles.forEach(p=>{
      if(p.orbit && mouse.x > -100){
        p.orbitAngle += p.orbitSpeed + bass*0.08;
        const tx = mouse.x + Math.cos(p.orbitAngle)*p.orbitR;
        const ty = mouse.y + Math.sin(p.orbitAngle)*p.orbitR;
        p.vx += (tx-p.x)*.015; p.vy += (ty-p.y)*.015;
      } else {
        const mdx=mouse.x-p.x, mdy=mouse.y-p.y, md=Math.sqrt(mdx*mdx+mdy*mdy);
        if(md<MDIST){
          const f=(MDIST-md)/MDIST*.018; p.vx+=mdx*f; p.vy+=mdy*f;
        }
      }
      p.x+=p.vx; p.y+=p.vy;
      const spd=Math.sqrt(p.vx*p.vx+p.vy*p.vy);
      if(spd>4){p.vx=p.vx/spd*4; p.vy=p.vy/spd*4;}
      if(p.x<0)p.x=W; if(p.x>W)p.x=0; if(p.y<0)p.y=H; if(p.y>H)p.y=0;
      p.hue=(p.hue+.2)%360;
      const pr = p.r * (1+bass*2);
      pctx.beginPath(); pctx.arc(p.x,p.y,pr,0,Math.PI*2);
      pctx.fillStyle=hsl(p.hue,100,75,.85); pctx.fill();
    });

    for(let i=0;i<particles.length;i++){
      for(let j=i+1;j<particles.length;j++){
        const a=particles[i],b=particles[j];
        const dx=a.x-b.x, dy=a.y-b.y, dist=Math.sqrt(dx*dx+dy*dy);
        const mda=Math.sqrt((mouse.x-a.x)**2+(mouse.y-a.y)**2);
        const thresh=mda<MDIST?CDIST*1.9:CDIST;
        if(dist<thresh){
          const alpha=(1-dist/thresh)*.65;
          pctx.beginPath(); pctx.moveTo(a.x,a.y); pctx.lineTo(b.x,b.y);
          pctx.strokeStyle=hsl((a.hue+b.hue)/2,100,70,alpha);
          pctx.lineWidth=.8; pctx.stroke();
        }
      }
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  //  LIGHTNING (bass-reactive, from logo center)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const logoEl = document.getElementById('logoBox');
  let logoCenter = {x: window.innerWidth/2, y: window.innerHeight/2};

  function updateLogoCenter(){
    const r = logoEl.getBoundingClientRect();
    logoCenter = {x: r.left+r.width/2, y: r.top+r.height/2};
  }
  setTimeout(updateLogoCenter, 200);

  // Recursive lightning bolt
  function lightningSegment(ctx, x1, y1, x2, y2, roughness, depth) {
    if (depth <= 0 || roughness < 1) {
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      return;
    }
    const mx = (x1+x2)/2 + (Math.random()-.5)*roughness;
    const my = (y1+y2)/2 + (Math.random()-.5)*roughness;
    lightningSegment(ctx, x1,y1, mx,my, roughness*0.55, depth-1);
    lightningSegment(ctx, mx,my, x2,y2, roughness*0.55, depth-1);
    // optional branch
    if(Math.random() < 0.35 && depth > 1){
      const blen = roughness * (0.5+Math.random());
      const ba = Math.atan2(y2-y1, x2-x1) + (Math.random()-.5)*1.2;
      const savedAlpha = ctx.globalAlpha;
      ctx.globalAlpha = savedAlpha * 0.45;
      lightningSegment(ctx, mx, my, mx+Math.cos(ba)*blen, my+Math.sin(ba)*blen, roughness*0.45, depth-2);
      ctx.globalAlpha = savedAlpha;
    }
  }

  let bolts = [];
  const BOLT_HUES = [180, 285, 55, 320, 120]; // cyan, violet, yellow, pink, green

  function spawnBolts(bass) {
    if (!audioReady || bass < 0.08) return;
    // number of new bolts scales with bass intensity
    const count = Math.floor(bass * 10);
    for(let i=0;i<count;i++){
      const angle = Math.random()*Math.PI*2;
      const len = 80 + Math.random()*(Math.max(W,H)*0.6)*bass;
      bolts.push({
        x1: logoCenter.x, y1: logoCenter.y,
        x2: logoCenter.x + Math.cos(angle)*len,
        y2: logoCenter.y + Math.sin(angle)*len,
        life: 1,
        decay: 0.07 + Math.random()*0.15,
        hue: BOLT_HUES[Math.floor(Math.random()*BOLT_HUES.length)],
        roughness: 35 + Math.random()*90*bass,
        depth: 4 + Math.floor(bass*4),
      });
    }
  }

  function drawLightning(bass) {
    lctx.clearRect(0,0,W,H);
    spawnBolts(bass);
    bolts = bolts.filter(b => b.life > 0.01);

    bolts.forEach(b => {
      b.life -= b.decay;
      if(b.life <= 0) return;
      const a = Math.max(0, b.life);

      // outer glow
      lctx.shadowBlur = 18 + bass*20;
      lctx.shadowColor = hsl(b.hue, 100, 70);
      lctx.strokeStyle = hsl(b.hue, 100, 80, a*0.65);
      lctx.lineWidth = 1.5;
      lctx.globalAlpha = a;
      lightningSegment(lctx, b.x1,b.y1,b.x2,b.y2, b.roughness, b.depth);

      // bright white core
      lctx.shadowBlur = 4;
      lctx.strokeStyle = `rgba(255,255,255,${a*0.85})`;
      lctx.lineWidth = 0.6;
      lightningSegment(lctx, b.x1,b.y1,b.x2,b.y2, b.roughness*0.4, Math.max(2,b.depth-2));

      lctx.globalAlpha = 1;
      lctx.shadowBlur = 0;
    });

    // Radial glow burst centered on logo on heavy bass hits
    if(bass > 0.3) {
      const grad = lctx.createRadialGradient(
        logoCenter.x,logoCenter.y,0,
        logoCenter.x,logoCenter.y,140*bass
      );
      grad.addColorStop(0, `rgba(255,255,255,${Math.min(bass*0.55,0.4)})`);
      grad.addColorStop(0.3, `rgba(0,255,255,${bass*0.28})`);
      grad.addColorStop(0.7, `rgba(255,0,255,${bass*0.1})`);
      grad.addColorStop(1, 'rgba(0,0,0,0)');
      lctx.fillStyle = grad;
      lctx.beginPath();
      lctx.arc(logoCenter.x,logoCenter.y,140*bass,0,Math.PI*2);
      lctx.fill();
    }
  }

  // Logo pulse on beat
  const logoText = document.getElementById('logoText');
  function animateLogo(bass) {
    const s = 1 + bass * 0.09;
    logoText.style.transform = `scale(${s}, ${1+bass*0.045})`;
    if(bass > 0.25) {
      logoText.style.textShadow =
        `0 0 ${15+bass*50}px rgba(255,255,255,${bass*0.9}),`+
        `0 0 ${50+bass*80}px rgba(0,255,255,${bass*0.6}),`+
        `0 0 ${80+bass*100}px rgba(255,0,255,${bass*0.3})`;
    } else {
      logoText.style.textShadow = '';
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  //  MAIN LOOP
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  resize();

  function loop(){
    const rawBass = getBassEnergy();
    smoothBass = smoothBass * 0.72 + rawBass * 0.28;
    const bass = smoothBass;

    drawBlobs(bass);
    drawPlasma(bass);
    drawTunnel(bass);
    drawParticles(bass);
    drawLightning(bass);
    animateLogo(bass);

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
</script>
</body>
</html>
