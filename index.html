<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>acidmartin.com</title>
  <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
    :root { --c1:#ff00ff; --c2:#00ffff; --c3:#ff6600; --c4:#00ff66; --c5:#6600ff; }
    html, body { width:100%; height:100%; overflow:hidden; background:#000; font-family:'Space Mono',monospace; }

    #blobCanvas     { position:fixed; inset:0; z-index:1; opacity:0.35; mix-blend-mode:screen; }
    #tunnelCanvas   { position:fixed; inset:0; z-index:3; }
    #particleCanvas { position:fixed; inset:0; z-index:4; }
    #boltCanvas     { position:fixed; inset:0; z-index:8; pointer-events:none; }

    body::after {
      content:''; position:fixed; inset:0;
      background-image:url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.08'/%3E%3C/svg%3E");
      background-size:200px 200px; pointer-events:none; z-index:5; opacity:0.4; mix-blend-mode:overlay;
    }

    .stage { position:fixed; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:10; pointer-events:none; }

    /* Logo â€” space between acid and martin via word-spacing */
    .glitch {
      font-size:clamp(3rem,10vw,8rem); font-weight:700; color:#fff;
      letter-spacing:0.05em; word-spacing:0.35em;
      text-transform:lowercase; position:relative;
      animation:flicker 8s infinite;
      transition:transform 0.04s;
      will-change:transform,opacity;
    }
    .glitch::before, .glitch::after { content:attr(data-text); position:absolute; inset:0; word-spacing:0.35em; }
    .glitch::before { color:var(--c1); clip-path:polygon(0 20%,100% 20%,100% 40%,0 40%); animation:glitch-top 3s infinite steps(2); mix-blend-mode:screen; }
    .glitch::after  { color:var(--c2); clip-path:polygon(0 60%,100% 60%,100% 80%,0 80%); animation:glitch-bot 2.5s infinite steps(2); mix-blend-mode:screen; }

    .sub { margin-top:1.5rem; font-size:clamp(0.7rem,2vw,1rem); letter-spacing:0.4em; text-transform:uppercase; color:rgba(255,255,255,0.5); animation:pulse-sub 4s ease-in-out infinite; }
    .sub::before { content:'â–¶ '; color:var(--c3); animation:blink 1s step-end infinite; }

    .scanline { position:fixed; inset:0; background:repeating-linear-gradient(to bottom,transparent 0px,transparent 3px,rgba(0,0,0,0.08) 3px,rgba(0,0,0,0.08) 4px); pointer-events:none; z-index:6; }
    .vignette  { position:fixed; inset:0; background:radial-gradient(ellipse at center,transparent 40%,rgba(0,0,0,0.85) 100%); pointer-events:none; z-index:7; }

    /* Border wrapper â€” liquid deformation applied here via JS clip-path */
    .rgb-border {
      position:relative; padding:2rem 4rem;
      border:1px solid rgba(255,255,255,0.08);
      animation:border-pulse 4s ease-in-out infinite;
      will-change:clip-path,box-shadow;
    }
    .rgb-border::before {
      content:''; position:absolute; inset:-2px;
      background:linear-gradient(90deg,var(--c1),var(--c2),var(--c3),var(--c4),var(--c5),var(--c1));
      background-size:300% 100%; border-radius:2px; z-index:-1;
      animation:rainbow-border 3s linear infinite; opacity:0.6;
    }
    .rgb-border::after { content:''; position:absolute; inset:0; background:rgba(0,0,0,0.92); z-index:-1; }

    #muteBtn {
      position:fixed; bottom:24px; right:24px; z-index:999;
      width:40px; height:40px; background:rgba(0,0,0,0.6);
      border:1px solid rgba(255,255,255,0.15); border-radius:50%;
      cursor:pointer; display:flex; align-items:center; justify-content:center;
      color:rgba(255,255,255,0.6); font-size:16px;
      transition:border-color 0.3s,box-shadow 0.3s;
      backdrop-filter:blur(8px); font-family:inherit;
    }
    #muteBtn:hover { border-color:rgba(0,255,255,0.5); color:#fff; box-shadow:0 0 12px rgba(0,255,255,0.3); }

    #startOverlay {
      position:fixed; inset:0; z-index:9999;
      display:flex; align-items:center; justify-content:center;
      background:rgba(0,0,0,0.9); cursor:pointer; flex-direction:column; gap:1.2rem;
    }
    #startOverlay span { font-family:'Space Mono',monospace; font-size:clamp(0.7rem,1.5vw,0.9rem); letter-spacing:0.35em; text-transform:uppercase; color:rgba(255,255,255,0.35); }
    #startOverlay .pulse-ring {
      width:80px; height:80px; border:2px solid rgba(0,255,255,0.6); border-radius:50%;
      display:flex; align-items:center; justify-content:center;
      color:rgba(0,255,255,0.8); font-size:28px; animation:ring-pulse 2s ease-in-out infinite;
    }

    @keyframes ring-pulse  { 0%,100%{box-shadow:0 0 0 0 rgba(0,255,255,0.3)} 50%{box-shadow:0 0 0 20px rgba(0,255,255,0)} }
    @keyframes glitch-top  { 0%{transform:translate(-3px,0)} 25%{transform:translate(3px,0)} 50%{transform:translate(-1px,0) skewX(5deg)} 75%{transform:translate(2px,0)} 100%{transform:translate(-3px,0)} }
    @keyframes glitch-bot  { 0%{transform:translate(3px,0)} 33%{transform:translate(-3px,0) skewX(-3deg)} 66%{transform:translate(1px,0)} 100%{transform:translate(3px,0)} }
    @keyframes flicker     { 0%,95%,100%{opacity:1} 96%{opacity:.4} 97%{opacity:1} 98%{opacity:.2} 99%{opacity:1} }
    @keyframes pulse-sub   { 0%,100%{opacity:.5} 50%{opacity:1;color:rgba(255,255,255,.9);letter-spacing:.5em} }
    @keyframes blink       { 0%,100%{opacity:1} 50%{opacity:0} }
    @keyframes rainbow-border { 0%{background-position:0% 50%} 100%{background-position:300% 50%} }
    @keyframes border-pulse { 0%,100%{box-shadow:0 0 0 transparent} 50%{box-shadow:0 0 30px rgba(255,0,255,.15),0 0 60px rgba(0,255,255,.1)} }
  </style>
</head>
<body>

<div id="startOverlay">
  <div class="pulse-ring">â–¶</div>
  <span>click to enter</span>
</div>

<audio id="bgAudio" loop>
  <source src="MOOD SWINGS fuckery.wav" type="audio/wav">
</audio>

<canvas id="blobCanvas"></canvas>
<canvas id="tunnelCanvas"></canvas>
<canvas id="particleCanvas"></canvas>
<canvas id="boltCanvas"></canvas>
<div class="scanline"></div>
<div class="vignette"></div>
<div class="stage">
  <div class="rgb-border" id="logoBox">
    <div class="glitch" data-text="Acid Martin" id="logoText">Acid Martin</div>
    <div class="sub">something is coming</div>
  </div>
</div>
<button id="muteBtn" title="Toggle sound">ðŸ”Š</button>

<script>
// â”€â”€â”€ AUDIO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const audio      = document.getElementById('bgAudio');
const muteBtn    = document.getElementById('muteBtn');
const startOverlay = document.getElementById('startOverlay');

let audioCtx, analyser, dataArray, bufferLength;
let audioReady = false;
let smoothBass = 0, smoothHihat = 0;

function initAudio() {
  if (audioReady) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const source = audioCtx.createMediaElementSource(audio);
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 2048;
  analyser.smoothingTimeConstant = 0.75;
  bufferLength = analyser.frequencyBinCount;
  dataArray = new Uint8Array(bufferLength);
  source.connect(analyser);
  analyser.connect(audioCtx.destination);
  audioReady = true;
}

startOverlay.addEventListener('click', () => {
  initAudio();
  audio.play().catch(()=>{});
  startOverlay.style.opacity = '0';
  startOverlay.style.transition = 'opacity 0.8s';
  setTimeout(() => startOverlay.style.display = 'none', 800);
});
muteBtn.addEventListener('click', () => {
  audio.muted = !audio.muted;
  muteBtn.textContent = audio.muted ? 'ðŸ”‡' : 'ðŸ”Š';
});

function getFreqBand(lo, hi) {
  if (!audioReady) return 0;
  analyser.getByteFrequencyData(dataArray);
  const nyquist = audioCtx.sampleRate / 2;
  const binHz   = nyquist / bufferLength;
  const a = Math.floor(lo / binHz), b = Math.floor(hi / binHz);
  let sum = 0;
  for (let i = a; i <= b; i++) sum += dataArray[i];
  return sum / ((b - a + 1) * 255);
}

// â”€â”€â”€ CANVAS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let W, H, cx, cy;
const mouse = { x:-9999, y:-9999 };
const blobCanvas     = document.getElementById('blobCanvas');
const tunnelCanvas   = document.getElementById('tunnelCanvas');
const particleCanvas = document.getElementById('particleCanvas');
const boltCanvas     = document.getElementById('boltCanvas');
const bctx = blobCanvas.getContext('2d');
const tctx = tunnelCanvas.getContext('2d');
const pctx = particleCanvas.getContext('2d');
const lctx = boltCanvas.getContext('2d');

function resize() {
  W = window.innerWidth; H = window.innerHeight; cx = W/2; cy = H/2;
  [blobCanvas, tunnelCanvas, particleCanvas, boltCanvas].forEach(c => { c.width=W; c.height=H; });
}
window.addEventListener('mousemove', e => { mouse.x=e.clientX; mouse.y=e.clientY; });
window.addEventListener('touchmove', e => { mouse.x=e.touches[0].clientX; mouse.y=e.touches[0].clientY; }, {passive:true});
window.addEventListener('resize', resize);
function hsl(h,s,l,a=1){ return `hsla(${h},${s}%,${l}%,${a})`; }

// â”€â”€â”€ BLOBS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const blobs = Array.from({length:5},(_,i)=>({
  x:Math.random()*window.innerWidth, y:Math.random()*window.innerHeight,
  vx:(Math.random()-.5)*.4, vy:(Math.random()-.5)*.4,
  r:130+Math.random()*170, hue:(i/5)*360,
  phase:Math.random()*Math.PI*2, morphSpeed:.003+Math.random()*.004,
}));

function drawBlobs(bass) {
  bctx.clearRect(0,0,W,H);
  blobs.forEach(b=>{
    b.x+=b.vx; b.y+=b.vy;
    if(b.x<-b.r)b.x=W+b.r; if(b.x>W+b.r)b.x=-b.r;
    if(b.y<-b.r)b.y=H+b.r; if(b.y>H+b.r)b.y=-b.r;
    b.hue=(b.hue+.08)%360; b.phase+=b.morphSpeed;
    const expand=1+bass*0.5;
    bctx.beginPath();
    for(let i=0;i<=12;i++){
      const angle=(i/12)*Math.PI*2;
      const morph=b.r*expand*(.72+.28*Math.sin(b.phase+i*1.1+Math.cos(b.phase*.7+i)));
      const x=b.x+Math.cos(angle)*morph, y=b.y+Math.sin(angle)*morph;
      i===0?bctx.moveTo(x,y):bctx.lineTo(x,y);
    }
    bctx.closePath();
    const g=bctx.createRadialGradient(b.x,b.y,0,b.x,b.y,b.r*expand);
    g.addColorStop(0,hsl(b.hue,100,65,.9));
    g.addColorStop(.5,hsl((b.hue+40)%360,100,50,.5));
    g.addColorStop(1,hsl((b.hue+80)%360,100,40,0));
    bctx.fillStyle=g; bctx.filter='blur(24px)'; bctx.fill(); bctx.filter='none';
  });
}

// â”€â”€â”€ TUNNEL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let tt=0;
const RINGS=44, SPOKES=14;
function drawTunnel(bass){
  tctx.clearRect(0,0,W,H);
  const maxR=Math.sqrt(cx*cx+cy*cy)*1.2;
  for(let i=RINGS;i>=0;i--){
    const p=i/RINGS, r=maxR*p, depth=1-p;
    const hue=(tt*30+i*15)%360, sat=80+Math.sin(tt*.5+i*.3)*20, lit=10+depth*20;
    tctx.beginPath(); tctx.arc(cx,cy,r,0,Math.PI*2);
    tctx.strokeStyle=hsl(hue,sat,lit,.15+depth*.2+bass*.2);
    tctx.lineWidth=1.5+bass*3; tctx.stroke();
  }
  for(let s=0;s<SPOKES;s++){
    const angle=(s/SPOKES)*Math.PI*2+tt*.2+bass*.5, hue=(tt*20+s*30)%360;
    tctx.beginPath(); tctx.moveTo(cx,cy);
    tctx.lineTo(cx+Math.cos(angle)*maxR,cy+Math.sin(angle)*maxR);
    const g=tctx.createLinearGradient(cx,cy,cx+Math.cos(angle)*maxR,cy+Math.sin(angle)*maxR);
    g.addColorStop(0,hsl(hue,100,60,.5+bass*.4));
    g.addColorStop(1,hsl((hue+180)%360,100,60,0));
    tctx.strokeStyle=g; tctx.lineWidth=1+bass*2; tctx.stroke();
  }
  tt+=.012;
}

// â”€â”€â”€ PARTICLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const N=120, CDIST=140, MDIST=220;
const particles=Array.from({length:N},(_,i)=>({
  x:Math.random()*window.innerWidth, y:Math.random()*window.innerHeight,
  vx:(Math.random()-.5)*.5, vy:(Math.random()-.5)*.5,
  r:1.5+Math.random()*2, hue:Math.random()*360,
  orbit:i<30, orbitR:25+Math.random()*90,
  orbitSpeed:(Math.random()-.5)*.05, orbitAngle:Math.random()*Math.PI*2,
}));
const cursorRings=[{r:18,phase:0,speed:0.05},{r:36,phase:2.1,speed:-0.035},{r:58,phase:4.2,speed:0.025}];
let cursorTime=0;

function drawParticles(bass){
  pctx.clearRect(0,0,W,H);
  if(mouse.x>0){
    cursorRings.forEach(ring=>{
      ring.phase+=ring.speed+bass*0.08;
      pctx.beginPath();
      for(let i=0;i<=20;i++){
        const a=(i/20)*Math.PI*2+ring.phase;
        const jitter=ring.r+(Math.random()-.5)*8*(1+bass*3);
        const x=mouse.x+Math.cos(a)*jitter, y=mouse.y+Math.sin(a)*jitter;
        i===0?pctx.moveTo(x,y):pctx.lineTo(x,y);
      }
      pctx.closePath();
      pctx.strokeStyle=hsl((cursorTime*80+ring.r*4)%360,100,72,.35+bass*.5);
      pctx.lineWidth=1.2; pctx.stroke();
    });
  }
  cursorTime+=0.016;
  particles.forEach(p=>{
    if(p.orbit&&mouse.x>-100){
      p.orbitAngle+=p.orbitSpeed+bass*0.08;
      const tx=mouse.x+Math.cos(p.orbitAngle)*p.orbitR;
      const ty=mouse.y+Math.sin(p.orbitAngle)*p.orbitR;
      p.vx+=(tx-p.x)*.015; p.vy+=(ty-p.y)*.015;
    } else {
      const mdx=mouse.x-p.x,mdy=mouse.y-p.y,md=Math.sqrt(mdx*mdx+mdy*mdy);
      if(md<MDIST){const f=(MDIST-md)/MDIST*.018; p.vx+=mdx*f; p.vy+=mdy*f;}
    }
    p.x+=p.vx; p.y+=p.vy;
    const spd=Math.sqrt(p.vx*p.vx+p.vy*p.vy);
    if(spd>4){p.vx=p.vx/spd*4; p.vy=p.vy/spd*4;}
    if(p.x<0)p.x=W; if(p.x>W)p.x=0; if(p.y<0)p.y=H; if(p.y>H)p.y=0;
    p.hue=(p.hue+.2)%360;
    const pr=p.r*(1+bass*2);
    pctx.beginPath(); pctx.arc(p.x,p.y,pr,0,Math.PI*2);
    pctx.fillStyle=hsl(p.hue,100,75,.85); pctx.fill();
  });
  for(let i=0;i<particles.length;i++){
    for(let j=i+1;j<particles.length;j++){
      const a=particles[i],b=particles[j];
      const dx=a.x-b.x,dy=a.y-b.y,dist=Math.sqrt(dx*dx+dy*dy);
      const mda=Math.sqrt((mouse.x-a.x)**2+(mouse.y-a.y)**2);
      const thresh=mda<MDIST?CDIST*1.9:CDIST;
      if(dist<thresh){
        const alpha=(1-dist/thresh)*.65;
        pctx.beginPath(); pctx.moveTo(a.x,a.y); pctx.lineTo(b.x,b.y);
        pctx.strokeStyle=hsl((a.hue+b.hue)/2,100,70,alpha);
        pctx.lineWidth=.8; pctx.stroke();
      }
    }
  }
}


// â”€â”€â”€ LIGHTNING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function lightningBolt(ctx,x1,y1,x2,y2,rough,depth){
  if(depth<=0){ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.stroke();return;}
  const mx=(x1+x2)/2+(Math.random()-.5)*rough;
  const my=(y1+y2)/2+(Math.random()-.5)*rough;
  lightningBolt(ctx,x1,y1,mx,my,rough*.55,depth-1);
  lightningBolt(ctx,mx,my,x2,y2,rough*.55,depth-1);
}

let bolts=[];
let logoCenter={x:window.innerWidth/2,y:window.innerHeight/2};
function updateLogoCenter(){
  const r=document.getElementById('logoBox').getBoundingClientRect();
  logoCenter={x:r.left+r.width/2,y:r.top+r.height/2};
}
setTimeout(updateLogoCenter,200);
window.addEventListener('resize', updateLogoCenter);

let prevBass=0;
const BOLT_HUES=[180,285,55,320];

function drawBolts(bass){
  lctx.clearRect(0,0,W,H);
  const transient=bass-prevBass;
  // Fire on moderate transients â€” low threshold so they appear frequently
  if(transient>0.04 && bass>0.15){
    const count=2+Math.floor(transient*25);
    for(let i=0;i<Math.min(count,6);i++){
      const angle=Math.random()*Math.PI*2;
      const len=150+Math.random()*Math.min(W,H)*0.5;
      bolts.push({
        x1:logoCenter.x, y1:logoCenter.y,
        x2:logoCenter.x+Math.cos(angle)*len,
        y2:logoCenter.y+Math.sin(angle)*len,
        life:1, decay:0.07+Math.random()*0.08,
        hue:BOLT_HUES[Math.floor(Math.random()*BOLT_HUES.length)],
        rough:40+Math.random()*70,
      });
    }
  }
  bolts=bolts.filter(b=>b.life>0.01);
  bolts.forEach(b=>{
    b.life-=b.decay;
    if(b.life<=0)return;
    const a=Math.max(0,b.life);
    // Thick outer glow pass
    lctx.globalAlpha=a*0.6;
    lctx.shadowBlur=30; lctx.shadowColor=hsl(b.hue,100,70);
    lctx.strokeStyle=hsl(b.hue,100,75,1);
    lctx.lineWidth=4;
    lightningBolt(lctx,b.x1,b.y1,b.x2,b.y2,b.rough,3);
    // Mid glow
    lctx.globalAlpha=a*0.85;
    lctx.shadowBlur=15;
    lctx.strokeStyle=hsl(b.hue,100,85,1);
    lctx.lineWidth=2;
    lightningBolt(lctx,b.x1,b.y1,b.x2,b.y2,b.rough*0.7,3);
    // Bright white core
    lctx.globalAlpha=a;
    lctx.shadowBlur=6;
    lctx.strokeStyle='rgba(255,255,255,1)';
    lctx.lineWidth=0.8;
    lightningBolt(lctx,b.x1,b.y1,b.x2,b.y2,b.rough*0.35,2);
    lctx.globalAlpha=1; lctx.shadowBlur=0;
  });
  prevBass=bass;
}

// â”€â”€â”€ BORDER WAVE CANVAS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Draws a traveling wave that runs around the border of the logo box
// The rectangle border stays intact â€” waves ripple outward from it on beat
const waveCanvas=document.createElement('canvas');
waveCanvas.style.cssText='position:fixed;inset:0;z-index:11;pointer-events:none;';
document.body.appendChild(waveCanvas);
const wctx=waveCanvas.getContext('2d');

let borderRect={x:0,y:0,w:0,h:0};
function updateBorderRect(){
  const r=document.getElementById('logoBox').getBoundingClientRect();
  borderRect={x:r.left,y:r.top,w:r.width,h:r.height};
}
setTimeout(updateBorderRect,250);
window.addEventListener('resize',()=>{updateLogoCenter();updateBorderRect();waveCanvas.width=W;waveCanvas.height=H;});

// Each wave pulse: travels around the perimeter, expands outward, fades
let wavePulses=[];
let waveHue=180;

function spawnWave(bass){
  // spawn a new outward ring wave on bass transient
  wavePulses.push({
    offset:0,         // how far outward the ring has expanded (px)
    life:1,
    decay:0.035+Math.random()*0.025,
    hue:waveHue,
    thickness:2.5+bass*6,
  });
  waveHue=(waveHue+40)%360;
}

function drawBorderWaves(bass){
  wctx.clearRect(0,0,W,H);
  if(!borderRect.w)return;

  const {x,y,w,h}=borderRect;
  const transient=Math.max(0,bass-prevBass);

  // Spawn waves on bass hits
  if(transient>0.05 && bass>0.15) spawnWave(bass);
  // Also spawn gentle ambient waves when music is playing
  if(audioReady && bass>0.05 && Math.random()<bass*0.15) spawnWave(bass*0.5);

  wavePulses=wavePulses.filter(p=>p.life>0.01);

  wavePulses.forEach(p=>{
    p.life-=p.decay;
    p.offset+=1.8+bass*4; // waves travel outward
    if(p.life<=0)return;
    const a=Math.max(0,p.life);
    const expand=p.offset;

    // Draw expanded rounded rect wave
    const wx=x-expand, wy=y-expand;
    const ww=w+expand*2, wh=h+expand*2;
    const radius=expand*0.4; // slight rounding grows with expansion

    wctx.beginPath();
    wctx.moveTo(wx+radius,wy);
    wctx.lineTo(wx+ww-radius,wy);
    wctx.quadraticCurveTo(wx+ww,wy,wx+ww,wy+radius);
    wctx.lineTo(wx+ww,wy+wh-radius);
    wctx.quadraticCurveTo(wx+ww,wy+wh,wx+ww-radius,wy+wh);
    wctx.lineTo(wx+radius,wy+wh);
    wctx.quadraticCurveTo(wx,wy+wh,wx,wy+wh-radius);
    wctx.lineTo(wx,wy+radius);
    wctx.quadraticCurveTo(wx,wy,wx+radius,wy);
    wctx.closePath();

    // Glow
    wctx.shadowBlur=12+bass*20;
    wctx.shadowColor=hsl(p.hue,100,65,a);
    wctx.strokeStyle=hsl(p.hue,100,75,a*(0.7+bass*0.3));
    wctx.lineWidth=p.thickness*(0.3+a*0.7); // thins as it fades
    wctx.stroke();
    wctx.shadowBlur=0;
  });
}

// â”€â”€â”€ LOGO: GLITCH + HI-HAT STROBE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const logoText=document.getElementById('logoText');
const logoBox=document.getElementById('logoBox');
let strobePhase=0;

function animateLogo(bass,hihat){
  const s=1+bass*0.09;

  // Hi-hat strobe
  strobePhase+=0.52;
  const strobeTick=Math.sin(strobePhase)>0.55;
  if(hihat>0.14&&strobeTick){
    logoText.style.opacity=0.12+Math.random()*0.45;
  } else {
    logoText.style.opacity=1;
  }

  // Glitch â€” dialed back sensitivity, still reactive
  const glitchAmp=bass*14+hihat*7;
  if(glitchAmp>2){
    const gx=(Math.random()-.5)*glitchAmp;
    const gy=(Math.random()-.5)*glitchAmp*0.4;
    const skew=(Math.random()-.5)*glitchAmp*0.3;
    logoText.style.textShadow=
      `${gx}px ${gy}px 0 rgba(255,0,255,${0.6+bass*0.3}),`+
      `${-gx}px ${-gy}px 0 rgba(0,255,255,${0.6+bass*0.3}),`+
      `0 0 ${15+bass*55}px rgba(255,255,255,${bass*0.75})`;
    const bigHit=bass>0.38&&Math.random()<bass*0.4;
    if(bigHit){
      logoText.style.transform=`scale(${s},${1+bass*0.045}) translate(${gx*1.6}px,${gy}px) skewX(${skew*1.2}deg)`;
      logoText.style.filter=`brightness(${1.4+bass}) contrast(${1.2+bass*0.4}) hue-rotate(${Math.random()*360}deg)`;
    } else {
      logoText.style.transform=`scale(${s},${1+bass*0.045}) translate(${gx*0.3}px,0px)`;
      logoText.style.filter='';
    }
  } else {
    logoText.style.textShadow='';
    logoText.style.transform=`scale(${s},${1+bass*0.045})`;
    logoText.style.filter='';
  }

  // Border glow
  if(bass>0.2){
    logoBox.style.boxShadow=
      `0 0 ${15+bass*40}px rgba(255,0,255,${bass*0.5}),`+
      `0 0 ${30+bass*60}px rgba(0,255,255,${bass*0.3})`;
  } else {
    logoBox.style.boxShadow='';
  }
}

// â”€â”€â”€ MAIN LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
resize();

function loop(){
  const rawBass  = getFreqBand(20, 250);
  const rawHihat = getFreqBand(8000, 16000);
  smoothBass  = smoothBass  * 0.72 + rawBass  * 0.28;
  smoothHihat = smoothHihat * 0.55 + rawHihat * 0.45;
  const bass  = smoothBass;
  const hihat = smoothHihat;

  drawBlobs(bass);
  drawTunnel(bass);
  drawParticles(bass);
  drawBolts(bass);
  drawBorderWaves(bass);
  animateLogo(bass, hihat);

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
